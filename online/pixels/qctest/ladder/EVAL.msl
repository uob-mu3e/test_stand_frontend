#############################################################################################################################       
    # Authors A. Loreti, March 2022, cosmic run. andrea.loreti@physics.ox.ac.uk
    #         J. Guzman-Funck, March 2022, cosmic run. jose.guzman-funck19@imperial.ac.uk || pepe.guzmanfunck@gmail.com
    # Summary: Eval evaluates the quality of the Ladder
    # User input: ladder ID 
    # Input from MIDAS: DACScan Input/Outputs -- IV Input/Outputs -- Lov voltage Output
    # Output single chip: to be done
    # Output ladder: the total score for the ladder and a breakthrough evaluation in array format, one netry for each test done
    #
    #
    # TODO
    # - Make sure that all info including inputs is saved. Maybe copy all input and outputs in each ladder folder
    #   and then do the actual evaluation
    #
#############################################################################################################################



# MAIN PATH TO MIDAS LADDER QUALITY CONTROL DIRECTORY
path_root = "/Equipment/Mupix/QCTests/Ladder"

# MAKE NEW KEY IN THE EVAL DIRECTORY WITH LADDER ID NUMBER IN IT
# The new key is a vector that stores evaluation outcomes for this ladder. Possible outcomes 0 (failed) 1(passed)
#
# TODO 
# - Check how to handle upstream, downstream
# - Check how to handle IDs 
# - Implement inmediate test failing if some specific tests fail: IV_curve, LV_power_ON
#

CAT path_Eval, $path_root, "/Eval"
PARAM ladderID, "Ladder identification number"
CAT Eval_output, $path_Eval, "/Ladders/", $ladderID
ODBCREATE $Eval_output, INT8, 4

# ODBSET $Eval_output[1], 0
# ODBSET $Eval_output[2], 0
# ODBSET $Eval_output[3], 0
# ODBSET $Eval_output[4], 0

# INITIALIZE TEST OUTCOMES WITH "0" (test not passed yet)
TEST_chip_config =0
TEST_IV=0
TEST_VPDAC=0
TEST_refVss=0

# TEST_IV = 0 
# TEST_LV_power_ON = 0 
# TEST_DAC_scan = 0 
# TEST_link_qual = 0 

# CONTROL VALUES 
#
# Ladder are 200 Ohm m or 20 Ohm m??
#
_brkdwnV_min = 10
_brkdwnV_max = 25
_min_config_current = 0.4
_VPDAC_gradient_min = -1
_VPDAC_gradient_max = 1

# Test sequence -->
#
#   (current) IV_curve --> LV_power_ON --> DAC_scan --> link_quali
#
#   (proposed) 
#
#

###################################### LV POWER ON TEST ##########################################
# TODO:
# - Output working chips.
# - Ladder test would fail but we can still output stuff about working chips. Discuss with Luigi to what extent this is interesting 
#

control_flag = 6

LOOP i,6
    CAT path_chip_config, $path_root, "/LVPowerOn/Output/current_increase[$i-1]"
    ODBGET $path_chip_config, chip_config_current

    IF $chip_config_current < $_min_config_current
        control_flag = $control_flag -1
    ENDIF
ENDLOOP

# Test passed
IF $control_flag==6
    TEST_chip_config=1
ENDIF

# ODBSET $Eval_output[1], $TEST_chip_config


###################################### LADDER IV TEST ##########################################
CAT path_IV_input, $path_root,"/IV/Input"
CAT path_IV_output, $path_root,"/IV/Output"

# Initialize variables before loop
this_current = 0
this_V = 0

# Loop index
LOOP i,32
    ODBGET $path_IV_output/Current[$i-1], this_current
    ODBGET $path_IV_output/Voltage[$i-1], this_V

    ODBGET /Equipment/Mupix/QCTests/Ladder/IV/Input/current_limit, max_current

    # We have exceeded max current. TODO. check goto
    IF $this_current>$max_current
        GOTO 110
    ENDIF
ENDLOOP

# Test passed 
IF $this_V > $_brkdwnV_min
    IF $this_V < $_brkdwnV_max
        TEST_IV = 1
    ENDIF
ENDIF

#ODBSET $Eval_output[2],$TEST_IV


###################################### LADDER VPDAC TEST ##########################################
# 
# Should have a linear increase
# 
# TODO:
# - Would be nice to be able to know what mupix fails
# - Check what to do with empty values
#

CAT path_VPDAC_input,  $path_root,"/DACScan/Input/VPDAC"
CAT path_VPDAC_output, $path_root,"/DACScan/Output/VPDAC/"


# Nr.of steps in VPDAC
ODBSUBDIR $path_VPDAC_input
    ODBGET start_value, vpdac_start
    ODBGET stop_value, vpdac_stop
    ODBGET step, vpdac_step
    VPDAC_steps = (($vpdac_stop-$vpdac_start) / $vpdac_step) + 1 
ENDODBSUBDIR


# Nr of chips
chips = 6

# Control_flag: 6 if ladder passed test, smaller than 6 otherwise
control_flag_1 = $chips

# This chip
chip = 0


LOOP i, $chips
    # Append this path till I say so
    CAT path_VPDAC, $path_VPDAC_output, $chip

    ODBSUBDIR $path_VPDAC
        control_flag_2 = $VPDAC_steps
        j_ = 0
        LOOP j, $VPDAC_steps/2
            ODBGET VPDAC_values[$j_], VPDAC_val_0
            ODBGET VPDAC_current[$j_], VPDAC_cur_0
            ODBGET VPDAC_values[$j], VPDAC_val_1
            ODBGET VPDAC_current[$j], VPDAC_cur_1

            control_flag_2 = $VPDAC_steps

            IF $VPDAC_val_1 != $VPDAC_val_0
                gradient = ($VPDAC_cur_1 - $VPDAC_cur_0)/($VPDAC_val_1 - $VPDAC_val_0)

                # TODO check if < and > logic is correctly put here
                IF $gradient < $_VPDAC_gradient_min
                    IF $gradient > $_VPDAC_gradient_max
                        control_flag_2 = $control_flag_2 -1
                    ENDIF
                ENDIF
            ELSE 
                control_flag_2 = $control_flag_2 -1
            ENDIF

            j_=$j
        ENDLOOP

        # Test for this chip passed 
        IF $control_flag_2 < $VPDAC_steps
            control_flag_1 = $control_flag_1 -1
        ENDIF

        chip = $i
    ENDODBSUBDIR
ENDLOOP


# Test for ladder passed 
IF $control_flag_1==$chips
    TEST_VPDAC=1
ENDIF
#ODBSET $Eval_output[2], $TEST_VPDAC


###################################### LADDER ref_Vss TEST ##########################################
#
# We need a plateau in the working region --> plateau around 190 +/- 30. I have 32 ref_Vss values. 
# Same idea as in previous test but now the gradient needs to be near zero... Empty values are zero
#
#

# For each mupix, check gradient increase in curernt as a function of the ref_Vss values. To do that navigate
# through each mupix, then thorugh each buffer, check what positions actually have a value different to zero.
# Check gradient increase in N-1 steps, if increase is bigger than min_gradient 

# Paths
CAT path_ref_Vss_input, $path_root, "DACScan/Input/ref_Vss"
CAT path_ref_Vss_output, "/DACScan/Output/ref_Vss"

# Run through full lader 
chips = 6
flag_chips_ref_Vss = $chips

buffer_size = 32

# TODO change. Check with Luigi
max_allowed_change = 0.1
gradient_target = 0

# TODO. Change if necessary
next_chip = 263

chip = 0
LOOP i, $chips
    LOOP j, $buffer_size-1
        CAT path_next_current, $path_ref_Vss_output, "/", $chip, "/ref_Vss_current[$j]"
        ODBGET $path_next_current, next_current
        
        # Check if filters works
        IF $next_value != 0
            CAT path_next_value, $path_ref_Vss_output, "/", $chip, "/ref_Vss_values[$j]"
            CAT path_this_current, $path_ref_Vss_output, "/", $chip, "/ref_Vss_current[$j-1]"
            CAT path_this_value, $path_ref_Vss_output, "/", $chip, "/ref_Vss_values[$j-1]"

            ODBGET $path_this_current, this_current
            ODBGET $path_next_value, next_value
            ODBGET $path_this_value, this_value

            gradient = ($next_current - $this_current) / ($next_value - this_value)

            IF abs($gradient-$gradient_target) > max_allowed_change
                # Failed test. Substract one. Exit loop
                flag_chips_ref_Vss = $flag_chips_ref_Vss - 1
                GOTO $next_chip
            ENDIF
        ELSE
            # No more values to be checked
            GOTO $next_chip
        ENDIF
    ENDLOOP

    chip = $i
ENDLOOP

# Check if ladder passed test
IF flag_chips_ref_Vss != $chips
    # Flag test as failed
    TEST_refVss = 0
ENDIF
